Design
~~~~~~~~~

Calculators on computers are sometimes unintuitive. To type math, we must go
to the numeric row and press a key. Sometimes, we have to go back to the mouse
and click a function that isn't mapped to the keyboard.

Touch Calculator is a way to type relatively simple, one line expressions with
ease. It transforms the trackpad into a full number pad plus a canvas to draw
on. Entering numbers is extremely fast--almost as fast as using a physical
numpad. But what Touch Calculator does differently is, if the user wants to
input a special character or function, one press goes to draw mode, and the user
can draw arbitrarily complex characters.


Approach
~~~~~~~~~
main.py is the main program window. It contains two displays (input/output) and
a classifier/calculator combo. The classifier is from the module classifier.py
and the calculator is from the calculator.py module.

The classifier makes use of several things. First, the raw input comes from
the touchpad, which is controlled using multitouch.py. The raw input is then
processed by process.py into feature vectors. Another module, called model.py,
contains training data for 32 characters. model.py also implements knn.py,
a machine learning algorithm that classifies based on Euclidean distance between
vectors. 

The feature vector produced by process.py is passed into model, which returns
a list of candidate characters and their confidence scores. These candidates
are displayed on the main classifier window for the user to select.

Touch button selection is also handled by a superclass of multitouch.py.

mathParser manages display strings and evaluation strings as input is added
and deleted.

When the user presses the equals button, input stored in the main program gets
passed to evaluate.py, which attempts to return either the answer or an error
message.

Other modules include fileIO.py, which handles data and model save/load, 
mouse.py which anchors the mouse at a certain point for useability, and
dataCollection.py, which can be used to train the classifier further.

eventBasedAnimation provides the animation framework, and appropriate
Tkinter bindings for the GUI.

Data files are stored in data/, while model files (which the classifier uses)
are stored in model/. The default model is "model3". Extra models were not
included for sake of file size. graphics/ contains .gif files used to draw
the user interface.

Testing is done with tests.py and testCanvas.py.

log/ contains a copy of the top level timesheet and a script to calculate 
total time spent on this project.

Finally, setup.py contains a script that can be run to build a standalone
application. See the readme.txt for information on that.






